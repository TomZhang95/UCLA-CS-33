1. -O2:

        xorl    %eax, %eax
        ret
By using -O2, compiler directly set the result as 0 since it knows overflow must happen
over there, and thus return 0 directly.


2. -O2 -fwrapv:

        movabsq $9223372036854775807, %rax
        addq    %rdi, %rax
        cmpq    %rax, %rdi
        setg    %al
        ret
The assembly code generated by -O2 -fwrapv is same as usual, or say it directly translate
corresponding C code into assembly code. Therefore overflow could happen and no warning 
would show up

3. -O2 -fsanitize=undefined:

        pushq   %rbp
        pushq   %rbx
        movabsq $9223372036854775807, %rdx
        movq    %rdi, %rbp
        movq    %rdi, %rbx
        subq    $8, %rsp
        addq    %rdx, %rbp
        jo      .L6
.L2:
        cmpq    %rbp, %rbx
        setg    %al
        addq    $8, %rsp
        popq    %rbx
        popq    %rbp
        ret
.L6:
        movq    %rdi, %rsi
        movl    $.Lubsan_data0, %edi
        call    __ubsan_handle_add_overflow
        jmp     .L2
For the -O2 -fsanitize=undefined, the compiler generate a normal translation at the 
beginning. If there is overflow happen, it will call a function called __ubsan_handle_add_overflow
to handle the overflow in addition, otherwise do normal operations.
